This summary is generated with the CodeBoarding-MCP to improve indexing of LLM agents.

# Codeboarding Overview

## on_boarding
**Mermaid Diagram Summary:**

- Orchestration & Workflow -[invokes analysis on]-> Static Code Analyzer
- Static Code Analyzer -[returns raw graph data to]-> Orchestration & Workflow
- Orchestration & Workflow -[consults and saves analysis to]-> Analysis Persistence
- Analysis Persistence -[provides cached analysis to]-> Orchestration & Workflow
- Orchestration & Workflow -[invokes with graph data]-> AI Analysis Engine
- AI Analysis Engine -[returns high-level model to]-> Orchestration & Workflow
- Orchestration & Workflow -[sends model for rendering to]-> Output Generator

## Details

One paragraph explaining the functionality which is represented by this graph. What the main flow is and what is its purpose.

### Orchestration & Workflow
The central coordinator managed by `DiagramGenerator`. It initiates static analysis (supporting multiple languages via LSP), triggers the AI engine (Planner, Meta, Abstraction, Details agents), coordinates with the persistence layer, and sends results to output generators.

**Related Classes/Methods**:

- `local_app.py`
- `github_action.py`
- `diagram_analysis/diagram_generator.py`
- `duckdb_crud.py`

### Static Code Analyzer
Responsible for parsing source code using LSP (Language Server Protocol) clients for Python, TypeScript, and Java. It builds call graphs, class hierarchies, and package dependencies. It uses a graph clustering algorithm to group related nodes.

**Related Classes/Methods**:

- `static_analyzer/__init__.py`
- `static_analyzer/graph.py`
- `static_analyzer/scanner.py`
- `static_analyzer/lsp_client/`

### AI Analysis Engine
The cognitive core. It uses specialized agents:
- **MetaAgent**: Analyzes project metadata and context.
- **PlannerAgent**: Plans the analysis strategy.
- **AbstractionAgent**: High-level architectural abstraction.
- **DetailsAgent**: Deep dive into specific components and clusters.

**Related Classes/Methods**:

- `agents/agent.py`
- `agents/planner_agent.py`
- `agents/abstraction_agent.py`
- `agents/details_agent.py`
- `agents/meta_agent.py`
- `agents/validation.py`

### Analysis Persistence
Handles serialization of analysis models to JSON. Supports caching to avoid re-analyzing unchanged components.

**Related Classes/Methods**:

- `diagram_analysis/analysis_json.py`
- `duckdb_crud.py` (Job status persistence)

### Output Generator
Renders analysis models into human-readable formats.

**Related Classes/Methods**:

- `output_generators/markdown.py`
- `output_generators/html.py`
- `output_generators/sphinx.py`
- `output_generators/mdx.py`

### Monitoring & Telemetry
(New) Provides observability into the analysis process, tracking LLM usage, tool calls, and performance stats.

**Related Classes/Methods**:

- `monitoring/__init__.py`
- `monitoring/stats.py`
- `monitoring/context.py`

### Utils & Helpers
Shared utilities for git operations, file system management, and environment setup.

**Related Classes/Methods**:

- `repo_utils/__init__.py` (Git operations, caching)
- `repo_utils/ignore.py`
- `install.py` (Installation and setup script)

### Evaluations
Framework for assessing static analysis performance, end-to-end pipeline reliability, and scalability.

**Related Classes/Methods**:

- `evals/base.py`
- `evals/cli.py`
- `evals/config.py`

## AI_Analysis_Engine
**Mermaid Diagram Summary:**

- PlannerAgent -[inherits from]-> LargeModelAgent
- AbstractionAgent -[inherits from]-> LargeModelAgent
- DetailsAgent -[inherits from]-> LargeModelAgent
- MetaAgent -[inherits from]-> LargeModelAgent
- PlannerAgent -[uses]-> MetaAgent
- AbstractionAgent -[uses]-> DetailsAgent

## Details

### LargeModelAgent
Abstract base class for all agents, handling LLM interaction, tools, and state.

**Related Classes/Methods**:

- `agents/agent.py`

### MetaAgent
Analyzes project metadata (dependencies, frameworks, patterns) to provide architectural context and bias to other agents.

**Related Classes/Methods**:

- `agents/meta_agent.py`

### PlannerAgent
Creates a high-level analysis plan, breaking down the codebase into manageable components.

**Related Classes/Methods**:

- `agents/planner_agent.py`

### AbstractionAgent
Performs the main high-level code analysis, identifying architectural patterns and component responsibilities.

**Related Classes/Methods**:

- `agents/abstraction_agent.py`

### DetailsAgent
Performs detailed analysis of specific components. It groups clusters within a component's subgraph and generating detailed insights. It validates consistency using the `ValidationContext` and validation functions.

**Related Classes/Methods**:

- `agents/details_agent.py`

### Validation & Consistency
A functional module providing validation logic (e.g., verifying cluster coverage and component relationships) used by agents to validate their outputs.

**Related Classes/Methods**:

- `agents/validation.py`

## Orchestration_Workflow
**Mermaid Diagram Summary:**

- Entrypoints -[invoke]-> DiagramGenerator
- DiagramGenerator -[invokes]-> StaticAnalyzer
- DiagramGenerator -[invokes]-> AI Agents
- DiagramGenerator -[updates]-> DuckDB

## Details

### Entrypoints
`local_app.py` for CLI and `github_action.py` for CI/CD.

### Analysis Orchestrator (DiagramGenerator)
Manages the pipeline:
1.  **Pre-analysis**: specific static analysis.
2.  **Meta Analysis**: Runs `MetaAgent`.
3.  **Planning**: Runs `PlannerAgent`.
4.  **Execution**: Runs `AbstractionAgent` and `DetailsAgent` in parallel/levels.
5.  **Output**: Generates files.

**Related Classes/Methods**:

- `diagram_analysis/diagram_generator.py`

### Job Management (DuckDB)
Manages the state of analysis jobs (queued, running, completed, gathered) using DuckDB.

**Related Classes/Methods**:

- `duckdb_crud.py`

## Static_Code_Analyzer
**Mermaid Diagram Summary:**

- StaticAnalyzer -[uses]-> ProjectScanner
- StaticAnalyzer -[creates]-> LSPClient (Python/TS/Java)
- LSPClient -[builds]-> CallGraph
- CallGraph -[clusters]-> ClusterResult

## Details

### StaticAnalyzer
The main facade that orchestrates the scanning and analysis process. It detects programming languages and spins up appropriate LSP clients.

**Related Classes/Methods**:

- `static_analyzer/__init__.py`

### ProjectScanner
Scans the repository to identify supported programming languages and project structures (e.g., finding `tsconfig.json` or `pom.xml`).

**Related Classes/Methods**:

- `static_analyzer/scanner.py`
- `static_analyzer/java_config_scanner.py`
- `static_analyzer/typescript_config_scanner.py`

### CallGraph & Clustering
Represents the code as a directed graph of nodes (methods, classes) and edges (calls). Implements adaptive clustering algorithms (Louvain, Leiden, Greedy Modularity) to group related code into meaningful clusters.

**Related Classes/Methods**:

- `static_analyzer/graph.py`

### LSP Clients
Interact with language servers (pyright, tsserver, jdtls) to extract accurate call graph and symbol information.

**Related Classes/Methods**:

- `static_analyzer/lsp_client/`

{
  "description": "The static analysis subsystem is designed to transform raw source code into structured Control Flow Graphs (CFGs) for subsequent architectural analysis. At its core, the `LSP Client` leverages external Language Servers to acquire comprehensive parsed information, including Abstract Syntax Trees (ASTs) and symbolic references, thereby centralizing complex parsing. This parsed information is then utilized by the `Reference Resolver` to accurately identify and resolve all symbolic connections within the codebase. For the generation of CFGs, the `Graph Builder` critically depends on the ASTs supplied by the `LSP Client` and the resolved references from the `Reference Resolver`. The `Scanner` performs lexical analysis, primarily for configuration files, under the guidance of `Programming Language Support`, which also provides essential language-specific configurations to both the `Scanner` and the `Graph Builder`. All resulting analysis artifacts, including the generated CFGs, are managed and made accessible through the `Analysis Result Handler`. This integrated approach ensures a robust and language-aware pipeline for deep code understanding.",
  "components": [
    {
      "name": "Scanner",
      "description": "Performs lexical analysis, breaking down source code into a stream of tokens. It handles language-specific tokenization, with specialized handling for configuration files (e.g., TypeScript).",
      "referenced_source_code": [
        {
          "qualified_name": "scanner",
          "reference_file": "static_analyzer/scanner.py",
          "reference_start_line": null,
          "reference_end_line": null
        },
        {
          "qualified_name": "typescript_config_scanner",
          "reference_file": "static_analyzer/typescript_config_scanner.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "LSP Client",
      "description": "Facilitates communication with Language Servers (e.g., TypeScript Language Server) to obtain rich parsed information, including Abstract Syntax Trees (ASTs), symbol tables, and references. This component offloads complex parsing logic to external language services, providing the primary source of ASTs for graph generation.",
      "referenced_source_code": [
        {
          "qualified_name": "client",
          "reference_file": "static_analyzer/lsp_client/client.py",
          "reference_start_line": null,
          "reference_end_line": null
        },
        {
          "qualified_name": "typescript_client",
          "reference_file": "static_analyzer/lsp_client/typescript_client.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "Reference Resolver",
      "description": "Resolves symbolic references within the code, utilizing parsed information from the LSP Client to ensure all connections between code elements are correctly identified. This is crucial for accurate graph generation and component identification.",
      "referenced_source_code": [
        {
          "qualified_name": "reference_resolve_mixin",
          "reference_file": "static_analyzer/reference_resolve_mixin.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "Graph Builder",
      "description": "Generates Control Flow Graphs (CFGs) from the ASTs provided by the LSP Client and the resolved references from the Reference Resolver. This is a critical step in understanding program execution flow and preparing the code for architectural clustering.",
      "referenced_source_code": [
        {
          "qualified_name": "graph",
          "reference_file": "static_analyzer/graph.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "Programming Language Support",
      "description": "Manages language-specific configurations, rules, and utilities, enabling the static analysis engine to support multiple programming languages effectively. It provides the necessary context for tokenization, parsing, and graph generation.",
      "referenced_source_code": [
        {
          "qualified_name": "programming_language",
          "reference_file": "static_analyzer/programming_language.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "Analysis Result Handler",
      "description": "Defines and manages the data structures used to store the various outputs of the static analysis process, including ASTs, CFGs, and the final clustered component representations. It acts as the interface for consuming analysis results.",
      "referenced_source_code": [
        {
          "qualified_name": "analysis_result",
          "reference_file": "static_analyzer/analysis_result.py",
          "reference_start_line": null,
          "reference_end_line": null
        }
      ]
    },
    {
      "name": "Unclassified",
      "description": "Component for all unclassified files and utility functions (Utility functions/External Libraries/Dependencies)",
      "referenced_source_code": []
    }
  ],
  "components_relations": [
    {
      "relation": "provides parsed information to",
      "src_name": "LSP Client",
      "dst_name": "Reference Resolver"
    },
    {
      "relation": "provides ASTs to",
      "src_name": "LSP Client",
      "dst_name": "Graph Builder"
    },
    {
      "relation": "integrates resolved references with",
      "src_name": "Reference Resolver",
      "dst_name": "Graph Builder"
    },
    {
      "relation": "provides configurations to",
      "src_name": "Programming Language Support",
      "dst_name": "Scanner"
    },
    {
      "relation": "provides configurations to",
      "src_name": "Programming Language Support",
      "dst_name": "Graph Builder"
    }
  ]
}
